\section{Implementation}

In this section we will present and comment all the code produced for the project.
As a first thing we want to show the library of fit function which constitute the core of the application.
These function were used in the sequential version of the application.

\lstinputlisting{./CODE/fit.h}

Let's consider the representation of the fit of an image.
This is accomplished by an array of double values which correspond to the parameters of a gaussian function.
The function $evaluateGaussian$ performs the estimation of the value of the gaussian on a given pixel:
\begin{center}
	$gaussian(x,y) = A * e^{( \frac{(X-x)^2}{SX} + \frac{(Y-y)^2}{SY} )} +a*x +b*x +c$
\end{center} 
This parameters also represents the actual state of the fit and are used by the function $procedure$ to perform one step of interpolation on a given image.
The gradient matrix and difference vector produced by the fit procedure are then elaborated by the function $post\_procedure$ in order to update the parameters of the gaussian accordingly to fit results.
This separation will come in handy when we will discuss the dataparallel implementation of the algorithm.
The function \textit{Initialization}, which also use $createMask$, $centroid$ and $maxmin$ functions, is used to produce an initial estimate of the gaussian parameters starting from the first image.
This function is necessary because otherwise the gauss-newton algorithm implemented in $procedure$ could diverge during the initial steps.

Last but not least there is the Connect function which is used to connect the server to the camera.

Now let's discuss some relevant details about the implementation of these functions.

\lstinputlisting{./CODE/fit.c}

As we can see from the code both the gradient matrix and the difference vector are allocated in static variables in order to avoid creation and disruption of the data structures at every invocation of the fit procedure. 
These variables are allocated after the inizialization of the application and freed at the end via $InitBuffers$ and $FreeBuffers$ functions.
The gsl library is exploited in both $procedure$ and $post\_procedure$ functions in orer to perform matrix-matrix, matrix-vector multiplication and solve a linear system.

